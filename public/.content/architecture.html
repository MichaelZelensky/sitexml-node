<h1>Architecture</h1>
<ul class="index">
    <li><a href="#summary">Summary</a></li>
    <li><a href="#filestructure">File structure</a></li>
    <li><a href="#sitexml">.site.xml</a></li>
    <li><a href="#sitecontent">Site content</a></li>
    <li><a href="#themes">Themes</a></li>
    <li><a href="#modules">Modules</a></li>
    <li><a href="#config">Configuring</a></li>
    <li><a href="#user">User and access management</a></li>
    <li><a href="#frontend">Frontend</a></li>
</ul>
<h2><a name="summary"></a>Summary</h2>
<p>SiteXML concept, or website standard consists of three main parts:</p>
<ol>
    <li>File structure standard</li>
    <li>Theming macrolanguage standard</li>
    <li>Site Transfer Protocol</li>
</ol>
<p>File structure is a representation of site tree and content. Aparently from using it as it is, this standard can be
    utilized for site backup and migration from CMS to CMS and from platform to platform.</p>
<p>Theming macrolanguage is a theme/template standard that can be used as an intermediate theming standard for different
    CMS. Using this standart aparently from using with native SiteXML <a href="/?id=9">tools</a> makes it possible to
    pick the same theme for many CMS's.</p>
<p>Site Transfer Protocol is a protocol for backend/frontend communication and development separatin. Using this
    standard, backend and frontend creators can develop their products independently. This can be very helpful, for
    example, when making a very rich beautiful frontend management tool without the need of influencing backend SiteXML
    solutions.</p>

<h2><a name="filestructure"></a>File structure</h2>
<p>SiteXML architecture in general is very simple. A SiteXML directory looks like this:</p>
<div class="bash">
    dev(user):/www/sitexml.info/htdocs$&gt;ls -l<br>
    total 46<br>
    drwxrwxr-x 5 user www 512 12 mar 09:01 ./<br>
    drwxr-xr-x 3 user www 512 10 mar 07:31 ../<br>
    -rw-r--r-- 1 user www 725 11 mar 16:17 .site.xml<br>
    drwxrwxr-x 2 user www 512 11 mar 08:43 .content/<br>
    drwxr-xr-x 3 user www 512 11 mar 08:24 .themes/<br>
    drwxr-xr-x 3 user www 512 11 mar 08:24 .modules/<br>

</div>
<p class="caption">Typical listing of SiteXML site root directory</p>
<p>And it is all you need to run a fully functional, interactive, dynamic, rich-editable site!</p><p>As you can see,
    there is just one XML file in the root directory, <span class="codestring">.site.xml</span>. This file contains site
    structure. Directories <span class="codestring">.content/</span>, <span class="codestring">.themes/</span>, <span
            class="codestring">.modules/</span> are self-explanatory and have in them exactly what is written on them:
    content, themes, and modules.</p>

<h2><a name="sitexml"></a>.site.xml</h2>

<p><span class="codestring">.site.xml</span> is the core of the idea. This is the central element of a SiteXML site - it
    contains information about site structure (page tree), navigation, styling (themes), content, meta tags; it gives
    directions to SiteXML engine about site's behaviour and how to generate pages. It used not only by backend engine,
    but it is also downloaded by the site frontend and used for ajax-browsing and site editing nd managing.</p>
<p><span class="codestring">.site.xml</span> is a file in site root, usually <span class="codestring">htdocs</span>, so
    it can be requested and got by client software, but it is better to protect it with OS-level access control, set it
    to <strong>not readable to everyone</strong>, because it can contain information, assumed not to be public, like
    draft pages of content. For requesting and getting <span class="codestring">.site.xml</span> by client there is a
    special request <span class="codestring">?sitexml</span> defined by STP. This request will return information
    depending on user's access level. Read more about STP commands in <%PLINK(7)%> section</p>
<p>This is an XML file with the structure, similar to this:<br></p>

<div class="codetitle">.site.xml</div>
<div class="code">
    &lt;site name="sitexml.info"&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;meta name="keywords"&gt;sitexml&lt;/meta&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;theme id="1" dir="theme16" file="index.thm" default="yes"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="1" name="header"&gt;header.html&lt;/content&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="2" name="footer"&gt;footer.html&lt;/content&gt;<br>
    &nbsp;&nbsp;&lt;/theme&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;page name="Preface" id="1" title="SiteXML.info - Preface" theme="1" startpage="yes"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;meta name="keywords"&gt;sitexml&lt;/meta&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="3" name="main"&gt;preface.html&lt;/content&gt;<br>
    &nbsp;&nbsp;&lt;/page&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;page name="Architecture" id="2"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="4" name="main"&gt;architecture.html&lt;/content&gt;<br>
    &nbsp;&nbsp;&lt;/page&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;page name="STP" id="3"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="5" name="main"&gt;stp.html&lt;/content&gt;<br>
    &nbsp;&nbsp;&lt;/page&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;page name="Reference" id="4"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="6" name="main"&gt;reference.html&lt;/content&gt;<br>
    &nbsp;&nbsp;&lt;/page&gt;<br>
    <br>
    &lt;/site&gt;<br>
</div>
<p class="caption">Typical listing of .site.xml file</p>


<h2><a name="sitecontent"></a>Site content</h2>

<p>Site content is what this is all brewing here for. This is the most massive part of the site, in terms of Kilobytes.
    The SiteXML idea about content is to break it into easily manageable and reusable HTML portions, similar to HTML
    pages in the past. A content file has nothing but HTML content.</p>

<p>The concept is very simple. All you need to know is that content is a HTML file, and it is tied with pages and themes
    in <span class="codestring">.site.xml</span>. If you do not specify its name in <span
            class="codestring">.site.xml</span>, nobody will see this content on your site.</p>

<p>As mentioned in file structure section earlier on this page, the whole site content hides in <span
        class="codestring">/.content/</span>&nbsp;directory. Here is the possible listing of the dir: <br><br></p>

<div class="bash">
    dev(user):/www/sitexml.info/htdocs/.content$&gt;ls -l<br>
    total 4<br>
    drwxrwxr-x 5 user www 512 12 mar 09:01 ./<br>
    drwxr-xr-x 3 user www 512 10 mar 07:31 ../<br>
    -rw-r--r-- 1 user www 725 11 mar 16:17 preface.html<br>
    -rw-r--r-- 1 user www 725 11 mar 16:18 architecture.html<br>
    -rw-r--r-- 1 user www 725 11 mar 16:37 stp.html<br>
    -rw-r--r-- 1 user www 725 11 mar 16:17 reference.html
</div>
<p class="caption">Typical listing of SiteXML site .content directory</p>
<p>Every one of the files listed here is a content portion for a content. You can edit it on the disk using your
    favorite text processor and the changes of course will be reflected on the site.</p><p>Here, for example, a typical
    content file:</p>
<div class="codetitle">.content/preface.html</div>
<div class="code">&lt;h1&gt;Preface&lt;/h1&gt;<br><br>
    &lt;p&gt;Internet is based on the HTML standard, developed in early 1990's by Tim Berners-Lee and colleagues. Today,
    HTML is only an illusion when speaking of server-side web technologies. It became so because of the browser war
    which took place on Earth some years later after the first site was published. While browser producers struggled to
    make Internet look better in their browsers, server-side developers distorted the idea of HTML, leaving aside most
    of its benefits.&lt;/p&gt;<br></div>
<p class="caption">Typical listing of a content file</p>
<p>As you can see, it is very simple inside and has nothing in it except HTML content. This is, by the way, our main
    goal.</p><p>In .site.xml example you might have noticed <span class="codestring">//site/page/content</span> element.
    The value of this element is <span class="codestring">preface.html</span>, this is the name of the above content
    file, so every page knows what content it has and any other pages can reuse that content in case of need.</p>
<div class="codetitle">.site.xml</div>
<div class="code">&lt;site&gt;<br>
    <br>
    &nbsp; &lt;page name="Preface" id="1" title="SiteXML.info - Preface" theme="1" startpage="yes"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="1" name="main"&gt;preface.html&lt;/content&gt;<br>&nbsp; &lt;/page&gt;<br>
    <br>
    &nbsp; &lt;page name="Anoter page" id="2"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;content id="2" name="main"&gt;preface.html&lt;/content&gt;<br>&nbsp; &lt;/page&gt;<br>
    <br>
    &lt;/site&gt;<br>
</div>
<p class="caption">Abstract from .site.xml, illustrating reusable content and relationship between content and
    pages.<br></p>
<p>
    Simple, isn't it? A page can have more that one content element, of course.

</p><p>Okay, okay, you would say, it is clear enough about site structure and content, though it is still not clear how
    to tie them together, but what about styling?<br></p>

<h2><a name="themes"></a>Themes</h2>

<p>In <span class="codestring">.site.xml</span> listing earlier on this page you could notice <span class="codestring">//site/theme</span>
    XML element. This element tells us that there is a theme that can be used for site styling. There can be many themes
    in one <span class="codestring">//site</span> container, and they are linked to a <span
            class="codestring">page</span> element by <span class="codestring">@theme</span> attribute:<br></p>

<div class="codetitle">.site.xml</div>
<div class="code">&lt;site name="sitexml.info"&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;theme <b>id="1"</b> dir="theme16" file="index.thm"&gt;&lt;/theme&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;page name="Preface" id="1" <b>theme="1"</b> startpage="yes"&gt;&lt;/page&gt;<br>
    <br>
    &lt;/site&gt;</div>
<p class="caption">An abstract from .site.xml, illustrating relationship between pages and themes.</p>
<p>In the above abstract you see that the&nbsp;<span class="codestring">//site/theme@id</span>&nbsp;parameter value is
    the same as the value of the&nbsp;<span class="codestring">//site/page@theme</span> parameter. This is the relation.
    Every page knows what theme is related to it. This is how pages are applied styling. From the abstract above you can
    learn that the theme file is located in <span class="codestring">theme16/index.thm</span>. The default location for
    themes is <span class="codestring">.themes</span> directory, so the full path to the theme in this example will be
    <span class="codestring">.themes/theme16/index.thm</span>.</p><p>Themes are just normal HTML files with content
    placeholders and macro-language injections, wrapped in <span class="codestring">&lt;% %&gt;</span> wrapper tags:</p>
<div class="codetitle">.themes/index.thm</div>
<div class="code">&lt;!DOCTYPE html&gt;<br><br>&lt;html lang="en"&gt;<br><br>&lt;head&gt;<br><br>&nbsp; &lt;title&gt;&lt;%TITLE%&gt;&lt;/title&gt;&nbsp;<br><br>&nbsp;
    &lt;link rel="stylesheet" href="&lt;%THEME_PATH%&gt;css/style.css" type="text/css" /&gt;<br><br>&nbsp; &lt;%META%&gt;<br><br>&lt;/head&gt;<br><br>&lt;body&gt;<br><br>&nbsp;
    &lt;div id="header"&gt;&lt;%THEMECONTENT(header)%&gt;&lt;/div&gt;<br><br>&nbsp; &lt;navi&gt;&lt;%NAVI%&gt;&lt;/navi&gt;<br><br>&nbsp;
    &lt;div id="banner"&gt;&lt;%CONTENT(banner)%&gt;&lt;/div&gt;&nbsp;<br><br>&nbsp; &lt;div id="content"&gt;&lt;%CONTENT(main)%&gt;&lt;/div&gt;<br><br>&nbsp;&nbsp;
    &lt;div
    id="footer"&gt;&lt;%THEMECONTENT(footer)%&gt;&lt;/div&gt;&nbsp;<br><br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></div>
<p class="caption">An example of theme HTML code</p>
<p>In the above example you see two types of placeholders:</p>
<ul>
    <li><span class="codestring">THEMECONTENT(name)</span></li>
    <li><span class="codestring">CONTENT(name)</span></li>
</ul><p>The first type of placeholders is a theme content placeholder. It is related to <span class="codestring">//site/theme/content@name</span>
    element.</p><p>If there is a content placeholder with a specific name in
    <span class="codestring">theme16/index.thm</span>, and if there is a <span
            class="codestring">//site/theme/content</span> element with this specific name in <span class="codestring">.site.xml</span>,
    then the content file, related to this element will be put as HTML instead of this placeholder. So, you can think of
    content placeholders as includes of content files.</p><p>The theme content is the same for all pages that use this
    theme, but this is a changeable part of themes, so you are free to deal with it the same way as with normal
    content.</p><p>The second type of content placeholder is used for page content. This placeholder is related to <span
        class="codestring">*/page/content@name</span> element. This content is unique for every page.</p><p>In the above
    abstract you can also see several examples of macrocommands, that can be used, by the way, not only on themes, but
    also on content HTML. These self-explanatory examples are <span class="codestring">TITLE</span>, <span
            class="codestring">META</span>, and <span class="codestring">THEME_PATH</span>. Of course, there are some
    more commands to be used.</p>
<ul>
    <li><span class="codestring">%SITENAME%</span></li>
    <li><span class="codestring">%META%</span></li>
    <li><span class="codestring">%TITLE%</span></li>
    <li><span class="codestring">%CONTENT(name)%</span></li>
    <li><span class="codestring">%NAVI%</span></li>
    <li><span class="codestring">%THEME_PATH%</span></li>
</ul>

<h2><a name="modules"></a>Modules</h2>

<p>Modules remain platform-dependent. There is not much we can do with it. Modules are interactive programming
    components that run on backend platform, written on a specific programming language and fully depend on platform
    configuration. We also cannot avoid using modules as platform-dependent elements while we are trying to make up a
    platform-independent system, because they are essencial for interactive sites.</p><p>There are two ways of using
    modules with SiteXML:<br></p><p>The first way is to use <span class="codestring">.site.xml</span> to create a navi
    link which leads to a page, completely built by a module (a server-side script with database and everything else).
    This is possible, but this is not the best way, because you cannot make much use of themes and site data in such
    case. This approach leads us to double efforts, but still it is possible.</p><p>The second way is to include module
    output on a specific page using <span class="codestring">content</span> element. It works similarly to using themes:
    you specify a path to a module executable and include its output in content placeholder.</p>
<div class="codetitle">.site.xml</div>
<div class="code">&lt;site name="sitexml.info"&gt;<br>
    <br>
    &nbsp;&nbsp;&lt;page name="Preface" id="1"<b></b>&gt;<br>&nbsp;&nbsp;&nbsp; &lt;content id="1" name="main"
    type="module"&gt;feedback/index.php&lt;/content&gt;<br>&nbsp; &lt;/page&gt;<br>
    <br>
    &lt;/site&gt;</div>
<p class="caption">An abstract from .site.xml, illustrating a module include.</p>

<h2><a name="config"></a>Configuring</h2>
<p>Similar to .htaccess, there is a configuration file <span class="codestring">.sitexml.cfg</span>, that tells engine
    how to treat errors, or other system-level things, like page title generation algorithm and other. Similar to
    .htaccess, configuration file is optional. More about configuration options refer to <%PLINK(12)%> section.</p>

<h2><a name="user"></a>User and access management</h2>
<p>There are four levels of access: read, read with ajax-browsing (simple client), edit content, and edit structure</p>
<p>SiteXML has native OpenId login system, and all users are stored in a file <span class="codestring">.users</span>

<h2><a name="frontend"></a>Frontend</h2>

<p>We find it important to include some front-end specifications to our concept. It is not very costly to include a
    handful of code strings into client (a browser or an HTML page) that will provide us with really handy functions,
    that are useful on every site of our scope. These functions are not provided by server-side SiteXML engine, but the
    engine posts with every generated page a specific set of data, which makes it possible to use a third-party frontent
    Javascript.</p><p>And, of course, these functions are fully backend-supported.<br></p><p>The functions are:<br></p>
<h3>Ajax-browsing</h3><p>When we browse a site, only 30% of its download is changeable data. The rest 70% is repeating
    HTML page layout, Javascript, CSS, images, backgrounds, flash, mediafiles that make up page styling. There is
    absolutely no need to download and build all that stuff again and again in your browser DOM. Ajax-browsing is a
    concept, in accordance with which you download only changeable content portions while browsing a site.&nbsp;</p><p>
    Each time you navigate from one page of a site to another, you stay in fact on the same URL, but it looks like URL
    has changed! Page title and URL are faked as if each new page was a new real URL, but if you bookmark this URL and
    try to open it in another browser window, or on another computer, the URLs will work as usual and will show you the
    page you were expecting to see. The same with the search engines—they will not execute Ajax-browsing JS code, they
    will crawl all your links and &nbsp;index all your pages as usual.</p><p>As to outdated browsers, they will browse
    your site in a good old manner, Ajax-browsing will not affect them: each page is a real new URL. This is called
    backward compatibility, fellows!</p><h3>Embedded authoring</h3><p>If you ever owned a website, or a blog, or maybe
    you have an experience of posting notes in a social network, you might know, how annoying it is to correct misprints
    and alter content after it has been published. Even if you only want to put a single forgotten comma, you must
    navigate to an admin section, then roll to the misfortune place, &nbsp;save your work, then check again your
    corrections, find another forgotten comma, and round, and round again.</p><p>To change this bad user experience
    forever, SiteXML sites has buit- in authoring. You change your site while reading. Forget about any
    heavy-to-load-and-run admin interfaces just to put a little poor lost comma. Correct it right at the moment you see
    it—this is good user experience.</p><h3>Embedded authorization<br></h3><p>Build-in authoring assumes
    authorization.</p><p>Today, identification is an the part of the Internet. Using OpenID allows us to simplify
    authorization process, bring it to front and avoid using intermediate software, like databases, though it is still
    very possible, of course, to make you own login system.</p>
